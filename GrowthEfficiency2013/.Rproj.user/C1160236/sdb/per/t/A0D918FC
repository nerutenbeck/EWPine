{
    "contents" : "###########################################################\n###\n### Influence of White Pine Growth Efficiecy Over Time\n### Nathan E. Rutenbeck\n### University of Maine School of Forest Resources\n### Spring 2013\n###\n###########################################################\n\nrm(list=ls())\nupdate.packages()\noptions(show.signif.stars=F)\nwindows()\n\nlibrary(ggplot2)\nlibrary(reshape)\nlibrary(doBy)\nlibrary(arm)\nlibrary(R2jags)\nlibrary(MCMCpack)\n\n\n\n################## Data preparation\n\n# Import plots\nplots.load<-read.table('Plots.txt',head=T,sep='\\t')\nplots.cl<-plots.load[,c(1:8,15)]\nnames(plots.cl)<-c('plotid','stand','plot','standid','trt','plot.ha','plot.m2','exp.fac','SI')\nplots<-plots.cl\n\nsummary(plots)\n\n# Import litterfall leaf areas from plots, clean variables, change names, reorder\nlitter.load<-read.table('Plot_litterfall.txt',head=T,sep='\\t') # litterfall data\nlitter.cl<-litter.load[,c(1:7)]\nnames(litter.cl)<-c('year','stand','trt','plot','plotid','LAI','LAI.SE')\nlitter<-orderBy(~plotid+year,data=litter.cl)\n\nsummary(litter)\n\nlai.plot<-ggplot(litter,aes(x=year,y=LAI))+geom_point()+\n  geom_errorbar(aes(ymax=LAI+LAI.SE,ymin=LAI-LAI.SE))\nlai.plot+facet_wrap(~plot) # LAI trends over time at the plot level\n\n# Import tree list and measurements from database\nDBtrees.load<-read.table('Trees.txt',head=T,sep='\\t') # tree measurements\nDBtrees.cl<-DBtrees.load[,c(3:8,2,9:12)] # tree.old matches tree number in windendro data....\nnames(DBtrees.cl)<-c('stand','plotid','plot','subplot','tree','tree.old','year','DBH','LLB','LLW','ht')\nDBtrees<-orderBy(~subplot+tree+year,data=DBtrees.cl) #clean up order\n\nsummary(DBtrees)\n\nDBtrees<-subset(DBtrees,DBH>0)\n\n# Read in ring data, get unique index, add calculated values\n\nwin<-read.table('windendro.txt',head=T,sep='\\t') # ring data\nwin.cl<-win[,c(1:6,13,38:ncol(win))] # Remove unused columns\nwinmelt<-melt(win.cl,id=1:8,na.rm=T) # Reshape data to desired structure\nwinmelt$Age<-unclass(winmelt$variable) # translate variables into ages\nwinmelt.cl<-winmelt[,c(4:6,1,3,7:8,10:11)]\nnames(winmelt.cl)<-c('stand','plot','subplot','tree',\n                     'pathid','ringcount','pathlength','seglength','age')\nsummary(winmelt.cl)\nwinmelt.cl[winmelt.cl$seglength>20,]\nwinmelt.cl<-winmelt.cl[winmelt.cl$seglength<20,] # Remove ridiculous outliers (only two)\nhist(winmelt.cl$seglength)\n\n# Make sure ring data identifiers match those of the Database trees\nnames(winmelt.cl)[4]<-'tree.old' # rename tree number to match field in database\n\nlevels(winmelt.cl$stand)%in%levels(DBtrees$stand)\nlevels(winmelt.cl$stand)\nlevels(DBtrees$stand)\nlevels(DBtrees$stand)[7]<-'Nutting'\nlevels(winmelt.cl$stand)%in%levels(DBtrees$stand)\n\nlevels(winmelt.cl$plot)%in%levels(DBtrees$plot)\nlevels(winmelt.cl$subplot)%in%levels(DBtrees$subplot)\n\ntreeids<-data.frame(treeid=1:nrow(unique(winmelt.cl[1:4])),\n                                  orderBy(~stand+plot+subplot+tree.old,\n                                          data=unique(winmelt.cl[1:4])))\nhead(treeids)\nnrow(treeids)\n\nrings.temp1<-merge(winmelt.cl,treeids,by=c('stand','plot','subplot','tree.old'))\nrings.temp2<-ddply(rings.temp1,.(treeid),mutate,year=2011-max(age)+age) #Calculate year ring formed\n\nrings.temp3<-orderBy(~stand+plot+subplot+tree.old+year,data=rings.temp2) # Order correctly by individual and year\n\n# Calculate mean segment length and area increment for each year.\nrings.mean<-ddply(rings.temp3,.(stand,plot,subplot,tree.old,treeid,year,age),summarize,\n                  mean.seg=mean(seglength),\n                  ainc.mm=pi*I(mean(seglength)^2)) \n\n# Predicted DIB in a given year will be the cumulative sum of average diameter increments\nrings<-ddply(rings.mean,.(treeid),mutate,\n             RIB=cumsum(mean.seg)/10,\n             DIB=2*cumsum(mean.seg)/10,\n             ainc.cm=ainc.mm/100) # Calculate predicted radius and diameter\nsummary(rings)\ntreeids$treeid%in%rings$treeid # nothing dropped...\n\n\n# Merge to get measured diameters and ring data all in the same place\n\ntrees.both<-merge(DBtrees,rings,by=c('stand','plot','subplot','tree.old','year'))\n\nsummary(trees.both)\n\n\nlevels(rings$stand)%in%levels(trees.both$stand)\nlevels(rings$plot)%in%levels(trees.both$plot)\nlevels(rings$subplot)%in%levels(trees.both$subplot)\nmiss<-treeids$treeid%in%trees.both$treeid # Lost some!\nlost<-treeids[!miss,]\nlost # Only two trees in rings but not in database\n# I have to live with it. I can't find plausible matches\n\n\n########################### Model Fitting\n\n# my own residual plot function\nrplot<-function(mod,...){\n  plot(resid(mod)~fitted(mod),pch=20,...)\n  abline(0,0,lty=3)\n}\n\n# Mean Absolute Bias function\nMAB<-function(model){\n  mab<-sum(abs(resid(model)))/length(resid(model))\n  return(mab)\n}\n\n# Root Mean Square Error\nRMSE<-function(model){\n  rmse<-sqrt(I(sum(I(resid(model)^2)))/length(resid(model)))\n  return(rmse)\n}\n\n# Diameter model\n\nDBH.mod1<-lmer(DBH~DIB+(1+DIB|treeid),data=trees.both)\nDBH.mod2<-lmer(DBH~DIB+ht+(1+DIB+ht|treeid),data=trees.both)\nDBH.mod3<-lmer(DBH~DIB+ht+age+(1+DIB+ht+age|treeid),data=trees.both)\nanova(DBH.mod1,DBH.mod2,DBH.mod3)\n\npdf('./DBH_fit.pdf',height=8,width=10)\npar(mfrow=c(3,1))\nrplot(DBH.mod1,ylim=c(-3,3), main='DBH~DIB')\nrplot(DBH.mod2,ylim=c(-3,3), main='DBH~DIB+ht')\nrplot(DBH.mod3,ylim=c(-3,3), main='DBH~DIB+ht+age') # Definitely the best.\npar(mfrow=c(1,1))\n\ndbh.resids<-melt(data.frame('DIB'=resid(DBH.mod1),'DIB+ht'=resid(DBH.mod2),'DIB+ht+age'=resid(DBH.mod3)))\n\ndbh.resid.hist<-ggplot(dbh.resids,aes(x=value))+geom_histogram(binwidth=0.1)+\n  xlab('DBH bias (cm)')+ggtitle('Residuals of Diameter Models')+facet_wrap(~variable)\n\ndbh.fitted<-melt(data.frame('DIB'=fitted(DBH.mod1),\n                           'DIB.ht'=fitted(DBH.mod2),'DIB.ht.age'=fitted(DBH.mod3)))\ndbh.fitted$obs<-rep(trees.both$DBH,3)\n\ndbh.fit.plot<-ggplot(dbh.fitted,aes(x=obs,y=value))+geom_point()+\n  geom_abline(slope=1,intercept=0)+facet_wrap(~variable)+xlab('Observed DBH')+ylab('Fitted DBH')\n\ndbh.fit.num<-melt(data.frame(model=c('DIB','DIB+ht','DIB+ht+age'),\n                            'AIC'=AIC(DBH.mod1,DBH.mod2,DBH.mod3)[[2]],\n                            'BIC'=BIC(DBH.mod1,DBH.mod2,DBH.mod3)[[2]]),id='model')\n\ndbh.fit.plot2<-ggplot(dbh.fit.num,aes(x=variable,y=value))+\n  geom_bar(stat='identity',aes(fill=variable))+facet_wrap(~model)\n\ndbh.fit.num2<-melt(data.frame(model=c('DIB','DIB+ht','DIB+ht+age'),\n                              'RMSE'=c(RMSE(DBH.mod1),RMSE(DBH.mod2),RMSE(DBH.mod3)),\n                              'MAB'=c(MAB(DBH.mod1),MAB(DBH.mod2),MAB(DBH.mod3))))\n\ndbh.fit.plot3<-ggplot(dbh.fit.num2,aes(x=variable,y=value))+\n  geom_bar(stat='identity',aes(fill=variable))+facet_wrap(~model)\n\ndbh.resid.hist\ndbh.fit.plot\ndbh.fit.plot2\ndbh.fit.plot3 \ndev.off()\n\nprint(dbh.fit.num)\nprint(dbh.fit.num2) # compare numerically\n\ndisplay(DBH.mod1)\ndisplay(DBH.mod1)\ndisplay(DBH.mod3) # Will use this model for volume prediction\n\n\nDBH.mod.coefs<-data.frame(treeid=rownames(coef(DBH.mod3)$treeid),\n                          coef(DBH.mod3)$treeid[1],coef(DBH.mod3)$treeid[2],\n                          coef(DBH.mod3)$treeid[3],coef(DBH.mod3)$treeid[4])\nnames(DBH.mod.coefs)<-c('treeid','d.b0','d.b1','d.b2','d.b3')\n\nhead(DBH.mod.coefs) # these are the varying coefficients for each of the J trees\n\n# I would like to display the model with the data for each tree, but that is hard to do\n# with so many predictors\n\n# DBH.plot<-ggplot(trees.both,aes(x=DIB,y=DBH))+\n#   geom_point()+geom_abline(data=DBH.mod.coefs,aes(intercept=DBH.ahat,slope=DBH.bhat))+\n#   facet_wrap(~treeid)\n\n# DBH.plot # shows tree level slope, intercept differences, individual prediction bias\n\n# Height models\n\nht.mod1<-lmer(ht~age+(1+age|treeid),trees.both)\nht.mod2<-lmer(ht~DIB+(1+DIB|treeid),trees.both)\nht.mod3<-lmer(ht~DIB+age+(1+DIB+age|treeid),trees.both)\nanova(ht.mod1,ht.mod2,ht.mod3) # Here it looks like model 3 performs the best.\n\npdf('./Ht_fit.pdf', height=8,width=10)\n\npar(mfrow=c(3,1))\nrplot(ht.mod1,ylim=c(-3,3),main='ht~age')\nrplot(ht.mod2,ylim=c(-3,3),main='ht~DIB')\nrplot(ht.mod3,ylim=c(-3,3),main='ht~DIB+age')\npar(mfrow=c(1,1))\n\n# Residuals above could be better...\n# I also wonder if I could improve height predictions by incorporating stand and plot effects.\nht.mod4<-update(ht.mod3,.~.+stand)\nht.mod5<-update(ht.mod3,.~.+plot)\nht.mod6<-update(ht.mod3,.~.+subplot)\n# Can't add multiple layers of plot/subplot because of fitting problems from correlation matrix.\n\nanova(ht.mod3,ht.mod4,ht.mod5,ht.mod6) # Here it looks like model 5 would improve things\n# Theoretically I should add plot factors as random effects to reflect experimental structure? \n# I don't have time now to explore\n\n#rplot(ht.mod5,ylim=c(-3,3),main='ht~plot+DIB+age')\n\nht.resids<-melt(data.frame('age'=resid(ht.mod1),'DIB'=resid(ht.mod2),\n                           'DIB+age'=resid(ht.mod3),'DIB+age+plot'=resid(ht.mod5)))\n\nht.resid.hist<-ggplot(ht.resids,aes(x=value))+geom_histogram(binwidth=0.1)+\n  xlab('ht bias (meters)')+ggtitle('Residuals of Height Models')+facet_wrap(~variable,nrow=1)\n\nht.fitted<-melt(data.frame('age'=fitted(ht.mod1),\n                           'DIB'=fitted(ht.mod2),\n                           'DIB.age'=fitted(ht.mod3),\n                           'DIB.age.plot'=fitted(ht.mod5)))\nht.fitted$obs<-rep(trees.both$ht,4)\n\nht.fit.plot<-ggplot(ht.fitted,aes(x=obs,y=value))+geom_point()+\n  geom_abline(slope=1,intercept=0)+facet_wrap(~variable)+\n  xlab('Observed Height')+ylab('Fitted Height')\n\nht.fit.num<-melt(data.frame(model=c('age','DIB','DIB.age','DIB.age.plot'),\n                            'AIC'=AIC(ht.mod1,ht.mod2,ht.mod3,ht.mod5)[[2]],\n                            'BIC'=BIC(ht.mod1,ht.mod2,ht.mod3,ht.mod5)[[2]]),id='model')\n\nht.fit.plot2<-ggplot(ht.fit.num,aes(x=variable,y=value))+\n  geom_bar(stat='identity',aes(fill=variable))+facet_wrap(~model,nrow=1)\n\nht.fit.num2<-melt(data.frame(model=c('age','DIB','DIB.age','DIB.age.plot'),\n                             'RMSE'=c(RMSE(ht.mod1),RMSE(ht.mod2),RMSE(ht.mod3),RMSE(ht.mod5)),\n                             'MAB'=c(MAB(ht.mod1),MAB(ht.mod2),MAB(ht.mod3),MAB(ht.mod5))))\n\nht.fit.plot3<-ggplot(ht.fit.num2,aes(x=variable,y=value))+\n  geom_bar(stat='identity',aes(fill=variable))+facet_wrap(~model,nrow=1)\n\nht.resid.hist\nht.fit.plot\nht.fit.plot2\nht.fit.plot3\n\ndev.off()\n\nprint(ht.fit.num)\nprint(ht.fit.num2) # compare numerically\n\ndisplay(ht.mod1)\ndisplay(ht.mod2)\ndisplay(ht.mod3)\ndisplay(ht.mod5) # Definitely select this one eventually, \n# but I don't have time to build the model matrix right now...\n\nht.mod.coefs<-data.frame(treeid=rownames(coef(ht.mod3)$treeid),coef(ht.mod3)$treeid)\n                         coef(ht.mod5)$treeid[1],coef(ht.mod5)$treeid[2]\nnames(ht.mod.coefs)<-c('treeid','ht.b0','ht.b1','ht.b2') #coefficients for heights\n\nhead(ht.mod.coefs)\n\n########## Bayesian fit for the simple diameter model. Eventually I'd like to try it with the full model\n# I went through a couple iterations of this model fitting, and finally\n# had to scale the variables and model the correlation with the inverse Wishart distribution to get it\n# to converge properly.\n\nDBH.jm<-function(){\n  for (i in 1:n){\n    y[i]~dnorm(yhat[i],tau.y)\n    yhat[i]<-a[treeid[i]]+b[treeid[i]]*x[i]    \n  }\n  tau.y<-pow(sigma.y,-2)\n  sigma.y~dunif(0,100)\n  \n  for(j in 1:J){\n    a[j]<-xi.a*B.raw[j,1] \n    b[j]<-xi.b*B.raw[j,2]\n    B.raw[j,1:2]~dmnorm(B.raw.hat[j,],Tau.B.raw[,])\n    B.raw.hat[j,1]<-mu.a.raw\n    B.raw.hat[j,2]<-mu.b.raw\n  }\n  mu.a<-xi.a*mu.a.raw # scaled mean slope\n  mu.b<-xi.b*mu.b.raw # scaled mean slope\n  mu.a.raw~dnorm(0,0.0001) # raw mean for intercepts\n  mu.b.raw~dnorm(0,0.0001) # raw mean for slopes\n  \n  xi.a~dunif(0,100) # Scaling parameters\n  xi.b~dunif(0,100)\n  \n  Tau.B.raw[1:2,1:2]~dwish(W[,],df) # modeling Tau directly with the Wishart distribution\n  df<-3 # degrees of freedom for the distribution of Tau.B.raw\n  \n  Sigma.B.raw[1:2,1:2]<-inverse(Tau.B.raw[,]) # Calculating raw sigmas\n  sigma.a<-xi.a*sqrt(Sigma.B.raw[1,1]) # caluculating scaled standard deviations for the intercepts\n  sigma.b<-xi.b*sqrt(Sigma.B.raw[2,2]) # calculating scaled standard deviations for the slopes\n  rho<-Sigma.B.raw[1,2]/sqrt(Sigma.B.raw[1,1]*Sigma.B.raw[2,2]) # Correlation\n}\n\ndbh.prep<-orderBy(~treeid,data=na.omit(trees.both[,c(12,8,17)]))\nhead(dbh.prep)\n\ndbh.dat<-with(dbh.prep,list(n=nrow(dbh.prep),\n                            J=length(unique(treeid)),\n                            y=DBH,\n                            x=DIB, # This makes the model not converge... Need to scale\n                            #x=scale(DIB,scale=T)[,1], # No convergence by just subt. mean...\n                            treeid=as.numeric(unclass(as.factor(treeid))),\n                            W=diag(2)))\nstr(dbh.dat)\ndbh.inits<-function(){\n  list(B.raw=array(rnorm(2*540),c(540,2)), # This is a Jx2 matrix of rnorm samples\n       mu.a.raw=rnorm(1),\n       mu.b.raw=rnorm(1),\n       sigma.y=runif(1),\n       Tau.B.raw=rwish(3,diag(2)), # rwish() from the MCMCpack package\n       xi.a=runif(1),\n       xi.b=runif(1))\n}\n\ndbh.params<-c('a','b','mu.a','mu.b','sigma.a','sigma.b','sigma.y','rho')\n\ndbh.fit<-jags(data=dbh.dat,inits=dbh.inits,dbh.params,model.file=DBH.jm,n.iter=500)\nprint(dbh.fit)\n\nmax(dbh.fit$BUGSoutput$summary[,8]) # Max Rhat - should be below 1.1 \n\ndbh.upd<-update(dbh.fit,n.iter=1000) # If convergence is problematic\n\nstr(dbh.fit)\n\ndbh.jagscoefs<-list(mean=dbh.fit$BUGSoutput$mean,sd=dbh.fit$BUGSoutput$sd,median=dbh.fit$BUGSoutput$median)\nstr(dbh.jagscoefs)\ndbh.jagscoefs$mean\n\n### Try the more complex model. As of the end of the term, this still doesn't work.\n\nDBH.jm2<-function(){\n  for (i in 1:n){\n    y[i]~dnorm(yhat[i],tau.y)\n    yhat[i]<-a[treeid[i]]+b[treeid[i]]*DIB[i]+c[treeid[i]]*ht[i]+d[treeid[i]]*age[i]    \n  }\n  tau.y<-pow(sigma.y,-2)\n  sigma.y~dunif(0,100)\n  \n  for(j in 1:J){\n    a[j]<-xi.a*B.raw[j,1] \n    b[j]<-xi.b*B.raw[j,2]\n    c[j]<-xi.c*B.raw[j,3]\n    d[j]<-xi.d*B.raw[j,4]\n    B.raw[j,1:4]~dmnorm(B.raw.hat[j,],Tau.B.raw[,])\n    B.raw.hat[j,1]<-mu.a.raw\n    B.raw.hat[j,2]<-mu.b.raw\n    B.raw.hat[j,3]<-mu.c.raw\n    B.raw.hat[j,4]<-mu.d.raw\n  }\n  mu.a<-xi.a*mu.a.raw \n  mu.b<-xi.b*mu.b.raw \n  mu.c<-xi.c*mu.c.raw\n  mu.d<-xi.d*mu.c.raw\n  mu.a.raw~dnorm(0,0.0001) \n  mu.b.raw~dnorm(0,0.0001) \n  mu.c.raw~dnorm(0,0.0001)\n  mu.d.raw~dnorm(0,0.0001)\n  \n  xi.a~dunif(0,100) \n  xi.b~dunif(0,100)\n  xi.c~dunif(0,100)\n  xi.d~dunif(0,100)\n  \n  Tau.B.raw[1:4,1:4]~dwish(W[,],df) \n  df<-5 \n  \n  Sigma.B.raw[1:4,1:4]<-inverse(Tau.B.raw[,]) \n  sigma.a<-xi.a*sqrt(Sigma.B.raw[1,1]) \n  sigma.b<-xi.b*sqrt(Sigma.B.raw[2,2]) \n  sigma.c<-xi.c*sqrt(Sigma.B.raw[3,3])\n  sigma.d<-xi.d*sqrt(Sigma.B.raw[4,4])\n\n  rho.ab<-Sigma.B.raw[1,2]/sqrt(Sigma.B.raw[1,1]*Sigma.B.raw[2,2]) \n  rho.ac<-Sigma.B.raw[1,3]/sqrt(Sigma.B.raw[1,1]*Sigma.B.raw[3,3])\n  rho.ad<-Sigma.B.raw[1,4]/sqrt(Sigma.B.raw[1,1]*Sigma.B.raw[4,4])\n  rho.bc<-Sigma.B.raw[2,3]/sqrt(Sigma.B.raw[2,2]*Sigma.B.raw[3,3])\n  rho.bd<-Sigma.B.raw[2,4]/sqrt(Sigma.B.raw[2,2]*Sigma.B.raw[4,4])\n  rho.cd<-Sigma.B.raw[3,4]/sqrt(Sigma.B.raw[3,3]*Sigma.B.raw[4,4])\n}\n\ndbh.prep2<-orderBy(~treeid,data=na.omit(trees.both[,c(12,8,11,13,17)]))\nhead(dbh.prep2)\n\ndbh.dat2<-with(dbh.prep2,list(n=nrow(dbh.prep2),\n                            J=length(unique(treeid)),\n                            y=DBH,\n                            DIB=scale(DIB)[,1],\n                            ht=scale(ht)[,1],\n                            age=scale(age)[,1],\n                            treeid=as.numeric(unclass(as.factor(treeid))),\n                            W=diag(4)))\nstr(dbh.dat2)\ndbh.inits2<-function(){\n  list(B.raw=array(rnorm(4*540),c(540,4)), # This is a Jx2 matrix of rnorm samples\n       mu.a.raw=rnorm(1),\n       mu.b.raw=rnorm(1),\n       mu.c.raw~rnorm(1),\n       mu.d.raw~rnorm(1),\n       sigma.y=runif(1),\n       Tau.B.raw=rwish(5,diag(4)), # rwish() from the MCMCpack package\n       xi.a=runif(1),\n       xi.b=runif(1),\n       xi.c=runif(1),\n       xi.d=runif(1))\n}\n\ndbh.params2<-c('mu.a','mu.b','mu.c','mu.d','sigma.a','sigma.b','sigma.c','sigma.d','sigma.y',\n              'rho.ab','rho.ac','rho.ad','rho.bc','rho.bd','rho.cd')\n\n# This still doesn't fit for some reason. Something wrong with the initialization?\n\ndbh.fit2<-jags(data=dbh.dat2,inits=dbh.inits2,dbh.params2,model.file=DBH.jm2,n.iter=50)\n\n# After all that, I have to say that you gotta love lmer()....\n\n\n######################### Growth Efficiency, finally...\n\n#Calculate annual volume increments\n\nall.trees<-merge(DBtrees[,c(1,3:4,6:8,11)],rings[-c(8:10)],\n                 by=c('stand','plot','subplot','tree.old','year'),all.y=T)\nnames(all.trees)\nhead(all.trees)\nmod.coefs<-merge(ht.mod.coefs,DBH.mod.coefs,by=('treeid'),all.y=T)\nsummary(mod.coefs)\ntreeids$treeid%in%mod.coefs$treeid # Just missing two trees...\n\ntree.master<-merge(mod.coefs,all.trees,by='treeid')\ntree.master<-orderBy(~treeid+age,data=tree.master)\nhead(tree.master,100)\nsummary(tree.master)\ntreeids$treeid%in%tree.master$treeid\n\nnames(tree.master)\n\n# diameter\n\ntree.master$ht.pred<-with(tree.master,ht.b0+I(ht.b1*DIB)+I(ht.b2*age))\ntree.master$dia.pred<-with(tree.master,d.b0+d.b1*DIB+d.b2*ht.pred+d.b3*age)\n\ntree.master$vol.pred<-with(tree.master,\n                           ((dia.pred/2.54)^2)/(0.971+(346.08/(ht.pred*3.2808399)))/35.31466672)\n\n\n# Calculate plot-level volumes\n\nplot.vols<-ddply(tree.master,.(stand,plot,year),summarize,\n                 ba=sum(ainc.cm),\n                 vol=sum(vol.pred))\n\nhead(plot.vols,100)\nlevels(plot.vols$plot) # So these are volumes in each given year, not increment!!!!\n\nplot.vols$vinc<-c(plot.vols$vol[1],rep(NA,nrow(plot.vols)-1))\n\nfor(i in 2:nrow(plot.vols)){\n  ifelse(plot.vols$plot[i]==plot.vols$plot[i-1],\n         plot.vols$vinc[i]<-plot.vols$vol[i]-plot.vols$vol[i-1],\n         plot.vols$vinc[i]<-plot.vols$vol[i])\n} # \nhead(plot.vols)\nplot.vols$sge<-with(plot.vols,vinc/vol)\n\n\nsummary(plot.vols)\nvolsmelt<-na.omit(melt(plot.vols[,-c(4:5)],id=1:3))\n\nlong.sge<-ggplot(volsmelt,aes(y=value,x=year,lty=variable))+geom_line(cex=0.7)+\n  facet_wrap(~plot)+ylim(0,2)+xlim(1950,2012)+\n  scale_linetype_discrete(labels=c(expression('VINC ('*m^3*')'),'Size GE'))\nlong.sge # not sure how much this means looking way back, but it's interesting to see.\n\n# Merge with litter data\n\nlevels(litter$plot)%in%levels(all.trees$plot) # I don't know what Chapman is, so....\n\nge<-merge(litter,plot.vols,by=c('plot','year'))\nlevels(ge$plot)\n\nhead(ge,100)\nge$F.GE<-with(ge,vinc/LAI)\nge$S.GE<-with(ge,vinc/vol)\nnames(ge)[3]<-'stand'\nnames(ge)\nge.rshp<-melt.data.frame(ge[,c(1:5,11,12)],id=1:5)\nhead(ge.rshp)\n\n\nge.rshp<-melt.data.frame(ge[,c(1:5,11,12)],id=1:5)\nhead(ge.rshp)\n\nfge.plot<-ggplot(ge.rshp[ge.rshp$plot!='Blue-Spring',],aes(y=value,x=year,color=trt,lty=variable))+\n  geom_line(cex=0.7)+facet_wrap(~plot)+\n  scale_linetype_discrete(labels=c(expression('VINC ('*m^3*')'),\n                                   'Foliar GE'))+\n  scale_color_discrete(labels=c('low density','light thin','no thin','PCT'),\n                       name='treatment')\n\nge.rshp2<-melt.data.frame(ge[,c(1:5,11,13)],id=1:5)\nhead(ge.rshp2)\n\nsge.plot<-ggplot(ge.rshp2[ge.rshp2$plot!='Blue-Spring',],aes(y=value,x=year,color=trt,lty=variable))+\n  geom_line(cex=0.7)+facet_wrap(~plot)+\n  scale_linetype_discrete(labels=c(expression('VINC ('*m^3*')'),\n                                   'Size GE'))+\n  scale_color_discrete(labels=c('low density','light thin','no thin','PCT'),\n                       name='treatment')\n\n\npdf('GE_plots.pdf',height=8,width=10)\n\nlai.plot+facet_wrap(~plot) # LAI trends over time at the plot level\nfge.plot # Foliar growth efficiency\nsge.plot # Size growth efficiency (modern)\n# long.sge # Size growth efficiency (historic and probably uninformative)\n\n# Make individual plots\nplts<-levels(ge$plot)[c(1:9,26:34)]\n\npar(ask=F)\nfor(i in 1:length(plts)){\n  tmp.i=subset(ge.rshp,plot==plts[i])\n  tmp2.i=subset(ge.rshp2,plot==plts[i])\n  print(ggplot(tmp.i,aes(y=value,x=year,lty=variable))+\n          geom_line(cex=0.8)+ggtitle(plts[i])+labs(linetype='')+ylab('')+\n          scale_linetype_discrete(labels=c(expression('VINC ('*m^3*')'),'Foliar GE')))\n  print(ggplot(tmp2.i,aes(y=value,x=year,lty=variable))+\n          geom_line(cex=0.8)+ggtitle(plts[i])+labs(linetype='')+ylab('')+\n          scale_linetype_discrete(labels=c(expression('VINC ('*m^3*')'),'Size GE')))\n   \n}\n\n\ndev.off()",
    "created" : 1368152949891.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3332502777",
    "id" : "A0D918FC",
    "lastKnownWriteTime" : 1368345762,
    "path" : "~/2013_Spring/Biometry/Project/WP_GE/Growth_efficiency.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}